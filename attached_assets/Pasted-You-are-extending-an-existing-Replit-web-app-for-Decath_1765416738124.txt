You are extending an existing Replit web app for Decathlon Camp Director Tools. The app already has a basic UI framework and routing for tools like the Lunchtime Job Assigner and AM/PM Job Assigner. **Do NOT rebuild the app from scratch.**

You MAY:
- Modify existing backend Python files and logic where needed to integrate the new behavior.
- Create new Python modules, helper functions, and UI components to interact with the existing pipelines.
- Adjust existing UI components (particularly the Lunchtime Jobs page and AM/PM Jobs page).

You MUST:
- **Keep edits to existing code as minimal as possible.** Prefer small, focused changes and thin adapter/wrapper functions over large refactors.
- Preserve the overall structure and routing of the existing app.
- Use the existing frontend stack and patterns already in the project.
- At the end, create or update a markdown file called `docs/IMPLEMENTATION_NOTES.md` that clearly lists:
  - Which files you created or modified,
  - What new endpoints, components, and functions you added,
  - How the UI talks to the backend pipelines,
  - How the History Saver works.

The GitHub repo with the latest backend code and structure is:
https://github.com/miles-wolf/Decathlon_Automation

Clone/sync that repo’s structure into this Replit project and overwrite existing backend files where appropriate so the Replit project matches the latest code in that repo (unless the Replit project is already up to date).

---

## 1. Data Source Changes (Staff List & Sessions)

**Goal:** Use `df_eligible_staff` in Python as the source of truth for staff lists and session-specific filtering, instead of relying on staff uploads.

### Requirements:

1. **Use `df_eligible_staff` for Staff Dropdowns**
   - Find where `df_eligible_staff` is defined/loaded in the Python backend.
   - Ensure there is a clear function or endpoint that:
     - Loads `df_eligible_staff`,
     - Filters it by `session_id`,
     - Returns a list of eligible staff for that session to the frontend.
   - **The staff dropdowns must only display staff that come from `df_eligible_staff` for the selected session.** The dropdown options should be generated by querying the dataframe for that `session_id`.

2. **Adding Unique Staff Not in the Database**
   - Camp directors must be able to add staff who are not yet in `df_eligible_staff` for a given run.
   - Provide a small UI section like “Add Staff Not in Database” where the director can input:
     - Staff name,
     - Group number (or group designation) they will be assigned to.
   - In the backend:
     - Look up the corresponding group ID from the group list dataframe (e.g., the dataframe that maps group numbers to group IDs).
     - Create a **new unique staff ID** for this custom staff member.
     - Add this staff entry (ID, name, group ID, session ID, etc.) into the in-memory set of eligible staff for that run (so they behave like normal staff for assignment purposes).
     - You do NOT need to permanently alter the underlying database for now; treat these as run-level additions, unless existing infrastructure makes persistent additions simple and safe.

3. **Session-Filtered Staff Dropdown**
   - The existing Lunchtime Job Assigner UI already has a **session selection dropdown**.
   - When a session is selected:
     - Fetch the list of eligible staff from `df_eligible_staff` filtered by that session, including any run-level custom staff added by the user.
     - Populate any staff dropdowns or multi-selects with this filtered list.
   - If a session has **no eligible staff**, show a clear message in the UI:
     - e.g., “No eligible staff found for this session in df_eligible_staff.”
     - Disable the “Generate Assignments” button in that case.

4. **Staff Upload Feature = Coming Soon**
   - The existing “Upload Staff List” feature should **remain visible** in the UI, but:
     - It should **NOT** be used for any current logic.
     - Replace its functionality with a clear “Coming Soon” state:
       - Disable its input elements,
       - Show a label like “Custom staff upload – Coming Soon”,
       - Optionally add a tooltip: “Staff currently comes from the internal df_eligible_staff dataset.”
   - Do NOT implement any override logic using uploaded staff lists yet.

---

## 2. File Updates & Backend Integration

1. **Sync with GitHub Repo**
   - Use the code from: `https://github.com/miles-wolf/Decathlon_Automation`.
   - Make sure the Replit backend (Python) matches the structure and files in this repo.
   - Overwrite any older versions of backend files with the newer repo versions where applicable.

2. **Respect Existing Pipelines**
   - There are already pipelines for:
     - Lunchtime jobs,
     - AM/PM jobs.
   - When you add UI features or new endpoints, **reuse these pipelines** instead of re-implementing their logic.
   - If you need to wrap them, create small adapter/helper functions rather than rewriting core logic.
   - Keep modifications to existing pipeline code minimal and localized.

3. **Implementation Notes**
   - After making changes, update `docs/IMPLEMENTATION_NOTES.md` with:
     - A list of changed/added files,
     - Short descriptions of what each new/changed function/endpoint does,
     - How the UI interacts with the job assignment pipelines and History Saver.

---

## 3. Lunchtime Job UI Updates (Multi-Week, Per-Session vs Per-Week Inputs)

**Goal:** Extend the Lunchtime Job Assigner UI to support multiple weeks of inputs and generate JSON configs per week, using example files in `Decathlon_automation/config/lunchjob_inputs/test_1012`.

### 3.1. Input Structure (Per-Session vs Per-Week)

Use the example input files inside:

- `Decathlon_automation/config/lunchjob_inputs/test_1012/`

as the canonical structure of what the backend expects.

Define the following conceptual structure:

- **Per-Session Inputs (apply to all weeks in that run):**
  - `session_id` (selected from existing session dropdown)
  - Any global flags or settings found in the example configs that apply to all weeks (if present).

- **Per-Week Inputs (unique for each week tab):**
  - Inputs reflected by the keys in the test_1012 JSON files, such as:
    - staff to add / extra staff
    - staff to remove
    - hardcoded job assignments (specific staff → specific jobs)
    - pattern-based jobs
    - special days (e.g., game days, tie-dye days, etc., if present in the JSON)
  - Do NOT hardcode assumptions; instead:
    - Inspect the keys in the example JSON files,
    - Mirror that structure into the UI as form fields.

### 3.2. Multi-Week UI

1. Add an input field for:
   - `Number of weeks` (integer).
2. When the user sets `Number of weeks = N`:
   - Dynamically create **N tabs**, one for each week:
     - “Week 1”, “Week 2”, … “Week N”.
   - Each week tab contains the per-week input fields based on the example JSON structure.
3. For each week:
   - The user can add/modify:
     - staff adds/removals,
     - hardcoded assignments,
     - other week-specific options based on the example config.

### 3.3. JSON Generation & Naming

When the user runs the Lunchtime Job Assigner for a session with N weeks configured:

1. Create a folder for that session at:
   - `Decathlon_automation/config/lunchjob_inputs/lunchjob_inputs_{session_id}/`
     - e.g. `.../lunchjob_inputs/lunchjob_inputs_1012/`
2. If the folder for that `session_id` already exists:
   - **Simply overwrite** its contents with the newly generated JSON files.
   - Do **not** prompt or warn the user about overwriting; assume they understand that older configs can be preserved only via History Saver.

3. For each week `k` from 1 to N:
   - Create a JSON file named:
     - `lunchjob_week{k}.json`
     - e.g. `lunchjob_week1.json`, `lunchjob_week2.json`, etc.
   - The JSON structure must match the example layout from `test_1012` and reflect the per-week inputs from the UI.

---

## 4. History Saver Tool

**Goal:** Implement a “History Saver” feature that can store and retrieve past **inputs and outputs** for any tool (Lunchtime Job Assigner, AM/PM Job Assigner, etc.).

### 4.1. Scope & Data to Save

For each run of a tool (e.g., Lunchtime or AM/PM):

- Save **both**:
  - The **inputs** (session id, number of weeks, per-week configs, added custom staff, etc.),
  - The **outputs** (resulting CSV paths, summary, Google Sheets info, etc.).

- Also store metadata such as:
  - Tool name (e.g., “Lunchtime Job Assigner” or “AM/PM Job Assigner”),
  - Session ID,
  - Timestamp of when the run happened,
  - Possibly a simple human-readable label (`{Tool} – Session {id} – {date/time}`).

### 4.2. Storage & Retention

- Implement History Saver using whatever storage layer the app is already using (e.g., a simple DB table or file-based store).
- For each tool and session combination:
  - Keep only the **last 10** history entries.
  - Older entries beyond the 10 most recent can be pruned.
- Allow users to **delete** specific history entries from the UI.

### 4.3. History UI

Create a **History Saver** section/tool in the UI:

- For each saved entry, show:
  - Tool name,
  - Session ID,
  - Timestamp,
  - Whether inputs, outputs, or both are available (we’re saving both).
- Actions per entry:
  - **Re-run with Saved Inputs**:
    - Reuse the previously saved inputs to run the tool again.
  - **View/Export Outputs**:
    - Show links to CSVs / Sheets, etc.
  - **Delete Entry**:
    - Remove the entry from history (with a confirmation dialog).

---

## 5. AM/PM Job Assigner Tool

**Goal:** Wire up the existing AM/PM job pipeline and simplify its UI so that it only depends on the session selection for now.

### 5.1. UI

- Use the same **session dropdown** pattern as Lunchtime Jobs.
- The only required input for now:
  - `session_id` (selected from dropdown).

- Show a main button:
  - “Generate AM/PM Assignments”

- Like the Lunchtime tool (see Section 7), the AM/PM tool page should use a **tabbed layout at the bottom**:
  - Tab 1: Main Summary & Controls
  - Tab 2: Table Preview (if possible)
  - Tab 3: Full Logs / Terminal Output

### 5.2. Behavior

When the user clicks “Generate AM/PM Assignments”:

1. Use the selected `session_id` to call the existing AM/PM job pipeline.
2. The pipeline should:
   - Generate a new CSV for that run.
   - Export / sync that CSV to the existing Google Sheet (see next section).
3. Pipe the run through:
   - The **main tab** (summary, status, major errors),
   - The **terminal/log output tab** (full log),
   - The **History Saver** (save both inputs and outputs).

For now, do **not** implement any extra features like:
- Randomize again,
- Manual override,
- Capacity previews.
We may add those later.

---

## 6. Google Sheets Integration (Both Tools)

**Google Sheet Link:**
https://docs.google.com/spreadsheets/d/1WFWFo55mfQlyto-SBnAcFOqUIt_kyvaHdpcjamBzXb4/edit?gid=2068869187#gid=2068869187

Both tools — Lunchtime Job Assigner and AM/PM Job Assigner — should:

1. Generate a new CSV each time they run.
2. Upload/sync that CSV to the appropriate tab in the above Google Sheet (use the existing integration / logic if present).
3. Expose the following in the UI for each tool:

### 6.1. “View Results” Button

- A button labeled like:
  - “View Google Sheet Results”
- Opens the above Sheet URL in a **new browser tab**.

### 6.2. “Copy Link” Button

- A small button/icon next to the sheet description:
  - Copies the Sheet URL to the clipboard.

### 6.3. “Last Updated” Timestamp

- Show a label near the sheet controls:
  - e.g., “Last updated: 2025-01-15 14:32 (Pacific Time)”
- Set/update this timestamp when:
  - A new job run successfully uploads to Google Sheets.

### 6.4. Optional Sheet Preview (Iframe)

- If technically feasible and allowed by CORS/permissions:
  - Embed a **read-only preview iframe** of the relevant Google Sheet section within the UI.
- If not feasible due to permissions, simply keep the “View Results” and “Copy Link” buttons.

---

## 7. Tabbed Layout, Terminal Output & Logging Panel

**Goal:** Each of the two job tools (Lunchtime & AM/PM) must have a UI at the bottom organized into **tabs**, with one of the tabs showing the real-time print/log output from the backend.

### 7.1. Bottom Tabs for Each Tool

For both the Lunchtime Job Assigner and AM/PM Job Assigner tool pages:

- Add a **tabbed interface at the bottom** of the page with at least three tabs:

1. **Tab 1: Summary & Controls (Main Tab)**
   - Shows:
     - High-level run status (success, failure, major messages),
     - The Google Sheet actions (“View Results”, “Copy Link”, “Last updated” timestamp),
     - The CSV download button (see Section 8.5),
     - Any main control actions such as:
       - “Generate Assignments” (may also be above),
       - Future options like “Regenerate these assignments”.
   - Major errors should be surfaced on this tab, even if the full details are in the Logs tab.

2. **Tab 2: Table Preview (If Possible)**
   - If feasible, display a preview table of the most recently generated assignments:
     - e.g., a simple dataframe-like table of assignments from the latest CSV.
   - If this is not feasible or is expensive to implement, you may:
     - Show a message like “Table preview not available yet – Coming Soon”.

3. **Tab 3: Logs / Terminal Output**
   - Shows the full terminal output/log for that run:
     - All print statements,
     - Detailed error traces,
     - Additional debugging information.

### 7.2. Log Features (Tab 3)

Within the Logs tab:

- **Display**:
  - Stream backend logs/print statements to this area in near real-time while a run is in progress.
  - Auto-scroll to the bottom as new logs are appended.

- **Log Level Filter Dropdown**:
  - Options: `All | Info | Warnings | Errors`
  - If logs include levels (e.g., via logging module), filter accordingly.
  - If they are plain print statements, infer severity by keywords where possible and implement a basic filter.

- **Copy Log Button**:
  - Copies the contents of the log panel to the clipboard.

- **Clear Log Button**:
  - Clears the log panel contents.

- **Color Coding**:
  - Success / normal info: green or default.
  - Warnings: yellow or highlighted.
  - Errors / exceptions: red.

---

## 8. Error Handling, Validation, Loading States, and Confirmations

### 8.1. Error Handling

When something goes wrong, the system should:

- Catch backend exceptions where reasonable,
- Relay a meaningful error message to the frontend,
- Display that message in the terminal/log panel and/or an error alert,
- **Suggest possible solutions** when obvious.

Specific cases:

1. **Database Connection Fails**:
   - Show a message like: 
     - “Error: Unable to connect to the database. Please check database configuration and connectivity.”
2. **Google Sheets Upload Fails**:
   - Show:
     - “Error uploading to Google Sheets. Please verify your Google credentials, sheet permissions, and network connection.”
3. **Malformed or Incomplete JSON Configs**:
   - Show:
     - “Error in week configuration. One or more required fields are missing or invalid for Week X.”
   - Where possible, identify the problematic field.

We do NOT need a separate “dry run” mode for now; just ensure errors are printed clearly and include hints.

### 8.2. Validation Rules

Implement **basic validation** before running pipelines where it’s straightforward, such as:

- Missing required fields (e.g., no session selected when required).
- Clearly conflicting or nonsensical entries in the UI where it’s easy to detect (e.g., obviously inconsistent per-week settings, if the pipeline would fail in a predictable way).

We **do not need to validate staff IDs** beyond ensuring that:
- Staff are selected only from the `df_eligible_staff`-based dropdown for the chosen session, plus any custom staff that the director adds through the “Add Staff Not in Database” UI.
- Custom staff added through the UI are given a valid unique ID and mapped to a valid group via the group list dataframe.

Show validation errors in a user-friendly way (e.g., small red text near the form and/or an alert), and **do not start the pipeline** until they are fixed.

### 8.3. Loading States

Show clear loading indicators during:

- Database queries loading staff/session data,
- Execution of the Python pipelines,
- Uploads to Google Sheets,
- History Saver read/write operations.

Use spinners/progress bars and disable relevant buttons during these operations to prevent double-submissions.

### 8.4. Confirmation Dialogs

Add confirmation dialogs for impactful actions:

1. **Running Assignments**:
   - Before starting a run, show a summary dialog:
     - e.g., “Run Lunchtime Job Assigner for Session 1012, Weeks 1–3?”
   - Include:
     - Session ID,
     - Number of weeks,
     - Tool name.
   - You do **not** need to show a confirmation dialog for overwriting existing session folder configs; those can be overwritten silently as described earlier.

### 8.5. Export Options Beyond Google Sheets

For each successful run (Lunchtime & AM/PM):

- Provide a **Download CSV** button:
  - Allows the user to download the generated CSV directly from the UI.

- Provide an **Email Results** option if feasible:
  - If emailing infrastructure already exists or can be added simply:
    - A small form to enter an email and send the CSV or a link.
  - If emailing is complex, it is acceptable to:
    - Implement only **Download CSV** now, and
    - Label email as “Email results – Coming Soon”.

---

## 9. Permissions (For Later)

For now:
- Assume only trusted internal users (e.g., camp directors) have access to the site.
- Do NOT implement role-based permissions or access control yet.

---

## Summary of What to Implement Now

1. Use `df_eligible_staff` to dynamically populate session-specific staff lists.
2. Allow adding custom staff not in the database by name + group, auto-assigning a unique ID and mapping them to the correct group via the group list dataframe.
3. Keep the staff upload UI visible but disabled and clearly labeled “Coming Soon”.
4. Sync backend code with the provided GitHub repo and integrate existing pipelines with minimal, focused code changes.
5. Extend the Lunchtime Job Assigner UI:
   - Multi-week input,
   - Week tabs for per-week inputs,
   - JSON generation per week (`lunchjob_week{k}.json`),
   - Session-specific folder structure (`lunchjob_inputs_{session_id}`) that overwrites silently.
6. Implement History Saver:
   - Save both inputs and outputs,
   - Keep last 10 entries per tool/session,
   - Re-run with saved inputs,
   - Allow deleting entries.
7. Wire up the AM/PM Job Assigner tool:
   - Session-only input,
   - Generate CSV and push to Google Sheets,
   - Integrate with History Saver and logging.
8. For both tools, add Google Sheet controls:
   - “View Results”, “Copy Link”, “Last updated” timestamp, and optional preview iframe.
9. For both tools, implement a **bottom tabbed layout**:
   - Tab 1: Summary & Controls (main outputs, buttons, major status),
   - Tab 2: Table Preview (if possible),
   - Tab 3: Logs (full terminal output panel with filters, copy, clear, color-coding, auto-scroll).
10. Implement error handling, basic validation, loading states, and run confirmations as described.
11. Document all file changes and behavior in `docs/IMPLEMENTATION_NOTES.md`.

Please implement all of the above within the existing Replit project structure, keeping modifications to existing code as minimal and targeted as possible.
